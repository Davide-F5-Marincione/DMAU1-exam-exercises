= 2016-06-14 Exam Exercises and Solutions 
:stem:

== Exercises

=== 1. Relational Algebra

Consider a database with the following schema, describing a manufacturer's operations:

====
`PRODUCTS([underline]#ID#, Description, UnitPrice)`

`WAREHOUSES([underline]#ID#, Address)`

`STOCKS([underline]#ProductID#, [underline]#WarehouseID#, Units)`
====

NOTE: `STOCKS` instances describe how many _products' units_ are stocked and in which _warehouses_. When a product is stocked, its number of `Units` is always positive, that is stem:["Units" >= 1].

Write *relational algebra expressions* for the following queries:

a. For each product whose stock is equal or larger than 10 units, _in any warehouse_, get both:

** the product's data (`ID`, `Description` and `UnitPrice`)
** the addresses of all the warehouses where at least 10 product units are stocked.

b. Find the `ID`, `Description` and `UnitPrice` of the products that _aren't_ stocked at all, anywhere.

TIP: You can load a sample RelaX dataset with the gist ID `126fcdb8c1bedc5080270dff5f642186`

<<<

== Solutions

=== 1. Relational Algebra

==== Question (a)

===== Insight

We must first identify the relations which contain all the required data. As it turns out, we need all of them:

* `STOCKS` contains the number of stocked units for each product
* `PRODUCTS` holds the data for products details
* `WAREHOUSES` includes the addresses

The easiest query consists of:

1. joining the three relations together, via *theta joins* where appropriate
2. performing a *selection* on the resulting relation, by filtering those tuples whose `Units` are equal or higher than 10
3. using a *projection* to pick out the attribute values we require

CAUTION: `PRODUCTS` and `WAREHOUSES` both feature an `ID` attribute, although these identify tuples in different relations, with different meanings. It wouldn't make sense to perform a *natural join* between them.

===== Answer

====
The following expression identifies the desired data:

[stem]
++++
bb r = (sigma_("Units" >= 10) "STOCKS") |><| _("WarehouseID" = "ID") "WAREHOUSES" |><| _("ProductID" = "PRODUCTS.ID") "PRODUCTS" \
++++

A less efficient _alternative_, due to more _joins_, could be:

[stem]
++++
bb r = sigma_("Units" >= 10) ("WAREHOUSES" |><| _("ID" = "WarehouseID") "STOCKS" |><| _("ProductID" = "PRODUCTS.ID") "PRODUCTS")
++++

We then need to select the relevant attributes, via a *projection* on stem:[bb r]:

[stem]
++++
Pi_("PRODUCTS.ID, Description, UnitPrice, Address") (bb r)
++++
====

===== RelaX Code

[source]
----
r = σ Units >= 10 STOCKS ⨝ WarehouseID = ID WAREHOUSES ⨝ ProductID = PRODUCTS.ID PRODUCTS
π PRODUCTS.ID, Description, UnitPrice, Address (r)
----

==== Question (b)

===== Insight

When tackling these queries *subtractions* are required. We find those tuples which _don't_ meet our criteria and we remove them from the set of all the tuples.

In this case we don't need to query the `WAREHOUSES` relation, seeing as it contains no relevant data for our purposes.

CAUTION: Products that _aren't_ stocked _don't appear_ in `STOCKS` instances; there are no such tuples whose `Units` value is stem:[0].

===== Answer

====
Let stem:[bb r] be the relation which includes the data of all those products we aren't interested in:

[stem]
++++
bb r = Pi_("ID, Description, UnitPrice") ("PRODUCTS" |><| _("ID" = "ProductID") "STOCKS")
++++

We are selecting *all* the tuples that match stocked products, referenced in `STOCKS` via the `ProductID` attribute. _Unstocked_ products, absent from `STOCKS`, won't be included in the _join_.

We finally *subtract* the data of all stocked products, stem:[bb r], from the set of all products (stocked and otherwise):

[stem]
++++
"PRODUCTS" - bb r
++++

====

NOTE: The initial *projection* ensures that the two relations' schemas are *compatible*, as required by the *subtraction*.

===== RelaX Code

[source]
----
PRODUCTS - π ID, Description, UnitPrice (PRODUCTS ⨝ ID = ProductID STOCKS)
----

